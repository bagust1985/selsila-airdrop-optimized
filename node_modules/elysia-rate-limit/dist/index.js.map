{"version":3,"file":"index.js","names":["unit: string","formatter: any","defaultKeyGenerator: Generator","reason: string","defaultOptions: Omit<Options, 'context'>","options: Omit<Options, 'context'>","key: string","key?: string","userOptions?: Partial<Options>","options: Options","app: Elysia","plugin","Elysia","clientKey: string | undefined","builtHeaders: Record<string, string>"],"sources":["../src/services/logger.ts","../src/services/defaultKeyGenerator.ts","../src/constants/defaultOptions.ts","../src/services/defaultContext.ts","../src/services/plugin.ts"],"sourcesContent":["import debug from 'debug'\n\n// create a cache of debug instances to avoid creating them on every call\nconst debugCache = new Map<string, debug.Debugger>()\n\nexport const logger = (unit: string, formatter: any, ...params: any[]) => {\n  const key = `elysia-rate-limit:${unit}`\n\n  let debugInstance = debugCache.get(key)\n  if (!debugInstance) {\n    debugInstance = debug(key)\n    debugCache.set(key, debugInstance)\n  }\n\n  debugInstance(formatter, ...params)\n}\n","import { logger } from './logger'\n\nimport type { Generator } from '../@types/Generator'\n\nexport const defaultKeyGenerator: Generator = (request, server): string => {\n  if (!server || !request) {\n    console.warn(\n      '[elysia-rate-limit] failed to determine client address (reason: server or request is undefined)'\n    )\n    return ''\n  }\n\n  // Get the IP info once to avoid redundant calls\n  const requestIpResult = server.requestIP(request)\n  const clientAddress = requestIpResult?.address\n\n  logger('generator', 'clientAddress: %s', clientAddress)\n\n  if (clientAddress === undefined) {\n    let reason: string\n\n    if (requestIpResult === null) reason = '.requestIP() returns null'\n    else if (requestIpResult.address === undefined)\n      reason = '.requestIP()?.address returns undefined'\n    else reason = 'unknown'\n\n    console.warn(\n      `[elysia-rate-limit] failed to determine client address (reason: ${reason})`\n    )\n\n    return ''\n  }\n\n  return clientAddress\n}\n","import { defaultKeyGenerator } from '../services/defaultKeyGenerator'\n\nimport type { Options } from '../@types/Options'\n\nexport const defaultOptions: Omit<Options, 'context'> = {\n  duration: 60000,\n  max: 10,\n  errorResponse: 'rate-limit reached',\n  scoping: 'global',\n  countFailedRequest: false,\n  generator: defaultKeyGenerator,\n  headers: true,\n  skip: () => false,\n}\n","import AllocQuickLRU from '@alloc/quick-lru'\n\nimport type { Context } from '../@types/Context'\nimport type { Options } from '../@types/Options'\nimport { logger } from './logger'\n\ninterface Item {\n  count: number\n  nextReset: Date\n}\n\nexport class DefaultContext implements Context {\n  private readonly id: string = (Math.random() + 1).toString(36).substring(7)\n  private readonly maxSize: number\n  private store!: AllocQuickLRU<string, Item>\n  private duration!: number\n\n  public constructor(maxSize = 5000) {\n    this.maxSize = maxSize\n  }\n\n  public init(options: Omit<Options, 'context'>) {\n    logger(\n      `context:${this.id}`,\n      'initialized with maxSize: %d, and expire duration of %d seconds',\n      this.maxSize,\n      options.duration / 1000\n    )\n\n    this.duration = options.duration\n    this.store = new AllocQuickLRU<string, Item>({\n      maxSize: this.maxSize,\n    })\n  }\n\n  public async increment(key: string) {\n    const now = new Date()\n    let item = this.store.get(key)\n\n    // if item is not found or expired, then issue a new one\n    if (item === undefined || item.nextReset < now) {\n      logger(\n        `context:${this.id}`,\n        'created new item for key: %s (reason: %s)',\n        key,\n        item === undefined ? 'not found' : 'expired'\n      )\n\n      item = {\n        count: 1,\n        nextReset: new Date(now.getTime() + this.duration),\n      }\n    }\n    // otherwise, increment the count\n    else {\n      logger(`context:${this.id}`, 'incremented count for key: %s', key)\n\n      item.count++\n    }\n\n    // update the store\n    this.store.set(key, item)\n\n    return item\n  }\n\n  public async decrement(key: string) {\n    const item = this.store.get(key)\n\n    // perform actions only if an item is found\n    if (item !== undefined) {\n      logger(`context:${this.id}`, 'decremented count for key: %s', key)\n\n      // decrement the count by 1\n      item.count--\n\n      // update the store\n      this.store.set(key, item)\n    }\n  }\n\n  public async reset(key?: string) {\n    logger(`context:${this.id}`, 'resetting target %s', key ?? 'all')\n\n    if (typeof key === 'string') this.store.delete(key)\n    else this.store.clear()\n  }\n\n  public kill() {\n    logger(`context:${this.id}`, 'clearing the store')\n\n    this.store.clear()\n  }\n}\n","import Elysia from 'elysia'\n\nimport { defaultOptions } from '../constants/defaultOptions'\nimport { DefaultContext } from './defaultContext'\n\nimport { logger } from './logger'\n\nimport type { Options } from '../@types/Options'\n\nexport const plugin = function rateLimitPlugin(userOptions?: Partial<Options>) {\n  const options: Options = {\n    ...defaultOptions,\n    ...userOptions,\n    context: userOptions?.context ?? new DefaultContext(),\n  }\n\n  options.context.init(options)\n\n  // NOTE:\n  // do not make plugin to return async\n  // otherwise request will be triggered twice\n  return function registerRateLimitPlugin(app: Elysia) {\n    const plugin = new Elysia({\n      name: 'elysia-rate-limit',\n      seed: options.max,\n    })\n\n    plugin.onBeforeHandle(\n      { as: options.scoping },\n      async function onBeforeHandleRateLimitHandler({\n        set,\n        request,\n        query,\n        path,\n        store,\n        cookie,\n        error,\n        body,\n        params,\n        headers,\n        // @ts-expect-error somehow qi is being sent from elysia, but there's no type declaration for it\n        qi,\n        ...rest\n      }) {\n        let clientKey: string | undefined\n        const enhancedRequest = Object.defineProperty(request, 'cookie', {value: cookie});\n\n        /**\n         * if a skip option has two parameters,\n         * then we will generate clientKey ahead of time.\n         * this is made to skip generating key unnecessary if only check for request\n         * and saving some cpu consumption when actually skipped\n         */\n        if (options.skip.length >= 2)\n          clientKey = await options.generator(\n            enhancedRequest,\n            options.injectServer?.() ?? app.server,\n            rest\n          )\n\n        // if decided to skip, then do nothing and let the app continue\n        if ((await options.skip(enhancedRequest, clientKey)) === false) {\n          /**\n           * if a skip option has less than two parameters,\n           * that's mean clientKey does not have a key yet\n           * then generate one\n           */\n          if (options.skip.length < 2)\n            clientKey = await options.generator(\n              completeRequest,\n              options.injectServer?.() ?? app.server,\n              rest\n            )\n\n          const { count, nextReset } = await options.context.increment(\n            // biome-ignore lint/style/noNonNullAssertion: <explanation>\n            clientKey!\n          )\n\n          const payload = {\n            limit: options.max,\n            current: count,\n            remaining: Math.max(options.max - count, 0),\n            nextReset,\n          }\n\n          // set standard headers\n          const reset = Math.max(\n            0,\n            Math.ceil((nextReset.getTime() - Date.now()) / 1000)\n          )\n\n          const builtHeaders: Record<string, string> = {\n            'RateLimit-Limit': String(options.max),\n            'RateLimit-Remaining': String(payload.remaining),\n            'RateLimit-Reset': String(reset),\n          }\n\n          // reject if limit were reached\n          if (payload.current >= payload.limit + 1) {\n            logger(\n              'plugin',\n              'rate limit exceeded for clientKey: %s (resetting in %d seconds)',\n              clientKey,\n              reset\n            )\n\n            builtHeaders['Retry-After'] = String(\n              Math.ceil(options.duration / 1000)\n            )\n\n            if (options.errorResponse instanceof Error)\n              throw options.errorResponse\n            if (options.errorResponse instanceof Response) {\n              // duplicate the response to avoid mutation\n              const clonedResponse = options.errorResponse.clone()\n\n              // append headers\n              if (options.headers)\n                for (const [key, value] of Object.entries(builtHeaders))\n                  clonedResponse.headers.set(key, value)\n\n              return clonedResponse\n            }\n\n            // append headers\n            if (options.headers)\n              for (const [key, value] of Object.entries(builtHeaders))\n                set.headers[key] = value\n\n            // set default status code\n            set.status = 429\n\n            return options.errorResponse\n          }\n\n          // append headers\n          if (options.headers)\n            for (const [key, value] of Object.entries(builtHeaders))\n              set.headers[key] = value\n\n          logger(\n            'plugin',\n            'clientKey %s passed through with %d/%d request used (resetting in %d seconds)',\n            clientKey,\n            options.max - payload.remaining,\n            options.max,\n            reset\n          )\n        }\n      }\n    )\n\n    plugin.onError(\n      { as: options.scoping },\n      async function onErrorRateLimitHandler({\n        set,\n        request,\n        query,\n        path,\n        store,\n        cookie,\n        error,\n        body,\n        params,\n        headers,\n        // @ts-expect-error somehow qi is being sent from elysia, but there's no type declaration for it\n        qi,\n        code,\n        ...rest\n      }) {\n        if (!options.countFailedRequest) {\n          const enhancedRequest = Object.defineProperty(request, 'cookie', {value: cookie});\n          const clientKey = await options.generator(\n            enhancedRequest,\n            options.injectServer?.() ?? app.server,\n            rest\n          )\n\n          logger(\n            'plugin',\n            'request failed for clientKey: %s, refunding',\n            clientKey\n          )\n          await options.context.decrement(clientKey)\n        }\n      }\n    )\n\n    plugin.onStop(async function onStopRateLimitHandler() {\n      logger('plugin', 'kill signal received')\n      await options.context.kill()\n    })\n\n    return app.use(plugin)\n  }\n}\n"],"mappings":"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"}