import Elysia$1 from "elysia";
import debug from "debug";
import AllocQuickLRU from "@alloc/quick-lru";

//#region src/services/logger.ts
const debugCache = new Map();
const logger = (unit, formatter, ...params) => {
	const key = `elysia-rate-limit:${unit}`;
	let debugInstance = debugCache.get(key);
	if (!debugInstance) {
		debugInstance = debug(key);
		debugCache.set(key, debugInstance);
	}
	debugInstance(formatter, ...params);
};

//#endregion
//#region src/services/defaultKeyGenerator.ts
const defaultKeyGenerator = (request, server) => {
	if (!server || !request) {
		console.warn("[elysia-rate-limit] failed to determine client address (reason: server or request is undefined)");
		return "";
	}
	const requestIpResult = server.requestIP(request);
	const clientAddress = requestIpResult?.address;
	logger("generator", "clientAddress: %s", clientAddress);
	if (clientAddress === void 0) {
		let reason;
		if (requestIpResult === null) reason = ".requestIP() returns null";
		else if (requestIpResult.address === void 0) reason = ".requestIP()?.address returns undefined";
		else reason = "unknown";
		console.warn(`[elysia-rate-limit] failed to determine client address (reason: ${reason})`);
		return "";
	}
	return clientAddress;
};

//#endregion
//#region src/constants/defaultOptions.ts
const defaultOptions = {
	duration: 6e4,
	max: 10,
	errorResponse: "rate-limit reached",
	scoping: "global",
	countFailedRequest: false,
	generator: defaultKeyGenerator,
	headers: true,
	skip: () => false
};

//#endregion
//#region src/services/defaultContext.ts
var DefaultContext = class {
	id = (Math.random() + 1).toString(36).substring(7);
	maxSize;
	store;
	duration;
	constructor(maxSize = 5e3) {
		this.maxSize = maxSize;
	}
	init(options) {
		logger(`context:${this.id}`, "initialized with maxSize: %d, and expire duration of %d seconds", this.maxSize, options.duration / 1e3);
		this.duration = options.duration;
		this.store = new AllocQuickLRU({ maxSize: this.maxSize });
	}
	async increment(key) {
		const now = new Date();
		let item = this.store.get(key);
		if (item === void 0 || item.nextReset < now) {
			logger(`context:${this.id}`, "created new item for key: %s (reason: %s)", key, item === void 0 ? "not found" : "expired");
			item = {
				count: 1,
				nextReset: new Date(now.getTime() + this.duration)
			};
		} else {
			logger(`context:${this.id}`, "incremented count for key: %s", key);
			item.count++;
		}
		this.store.set(key, item);
		return item;
	}
	async decrement(key) {
		const item = this.store.get(key);
		if (item !== void 0) {
			logger(`context:${this.id}`, "decremented count for key: %s", key);
			item.count--;
			this.store.set(key, item);
		}
	}
	async reset(key) {
		logger(`context:${this.id}`, "resetting target %s", key ?? "all");
		if (typeof key === "string") this.store.delete(key);
		else this.store.clear();
	}
	kill() {
		logger(`context:${this.id}`, "clearing the store");
		this.store.clear();
	}
};

//#endregion
//#region src/services/plugin.ts
const plugin = function rateLimitPlugin(userOptions) {
	const options = {
		...defaultOptions,
		...userOptions,
		context: userOptions?.context ?? new DefaultContext()
	};
	options.context.init(options);
	return function registerRateLimitPlugin(app) {
		const plugin$1 = new Elysia$1({
			name: "elysia-rate-limit",
			seed: options.max
		});
		plugin$1.onBeforeHandle({ as: options.scoping }, async function onBeforeHandleRateLimitHandler({ set, request, query, path, store, cookie, error, body, params, headers, qi,...rest }) {
			let clientKey;
			const enhancedRequest = Object.defineProperty(request, "cookie", { value: cookie });
			/**
			* if a skip option has two parameters,
			* then we will generate clientKey ahead of time.
			* this is made to skip generating key unnecessary if only check for request
			* and saving some cpu consumption when actually skipped
			*/
			if (options.skip.length >= 2) clientKey = await options.generator(enhancedRequest, options.injectServer?.() ?? app.server, rest);
			if (await options.skip(enhancedRequest, clientKey) === false) {
				/**
				* if a skip option has less than two parameters,
				* that's mean clientKey does not have a key yet
				* then generate one
				*/
				if (options.skip.length < 2) clientKey = await options.generator(completeRequest, options.injectServer?.() ?? app.server, rest);
				const { count, nextReset } = await options.context.increment(clientKey);
				const payload = {
					limit: options.max,
					current: count,
					remaining: Math.max(options.max - count, 0),
					nextReset
				};
				const reset = Math.max(0, Math.ceil((nextReset.getTime() - Date.now()) / 1e3));
				const builtHeaders = {
					"RateLimit-Limit": String(options.max),
					"RateLimit-Remaining": String(payload.remaining),
					"RateLimit-Reset": String(reset)
				};
				if (payload.current >= payload.limit + 1) {
					logger("plugin", "rate limit exceeded for clientKey: %s (resetting in %d seconds)", clientKey, reset);
					builtHeaders["Retry-After"] = String(Math.ceil(options.duration / 1e3));
					if (options.errorResponse instanceof Error) throw options.errorResponse;
					if (options.errorResponse instanceof Response) {
						const clonedResponse = options.errorResponse.clone();
						if (options.headers) for (const [key, value] of Object.entries(builtHeaders)) clonedResponse.headers.set(key, value);
						return clonedResponse;
					}
					if (options.headers) for (const [key, value] of Object.entries(builtHeaders)) set.headers[key] = value;
					set.status = 429;
					return options.errorResponse;
				}
				if (options.headers) for (const [key, value] of Object.entries(builtHeaders)) set.headers[key] = value;
				logger("plugin", "clientKey %s passed through with %d/%d request used (resetting in %d seconds)", clientKey, options.max - payload.remaining, options.max, reset);
			}
		});
		plugin$1.onError({ as: options.scoping }, async function onErrorRateLimitHandler({ set, request, query, path, store, cookie, error, body, params, headers, qi, code,...rest }) {
			if (!options.countFailedRequest) {
				const enhancedRequest = Object.defineProperty(request, "cookie", { value: cookie });
				const clientKey = await options.generator(enhancedRequest, options.injectServer?.() ?? app.server, rest);
				logger("plugin", "request failed for clientKey: %s, refunding", clientKey);
				await options.context.decrement(clientKey);
			}
		});
		plugin$1.onStop(async function onStopRateLimitHandler() {
			logger("plugin", "kill signal received");
			await options.context.kill();
		});
		return app.use(plugin$1);
	};
};

//#endregion
export { DefaultContext, defaultOptions, plugin as rateLimit };
//# sourceMappingURL=index.js.map